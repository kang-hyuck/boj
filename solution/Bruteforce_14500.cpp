/* Bruteforce_14500, 테트리미노 */
/* 포인트
 (브루트포스) 문제
 1. 모든 모양의 dy,dx를 만들어 본다. [모양 종류][모양의 칸수] 로 만들면 된다 (생각없이 문제 풀다보니 나는 3차원으로 했다 ㅠ.ㅠ)
 2. 맵을 모두 돌면서 "각각의 위치"에서 1.모양을 넣을 수 있는지(CheckRange()) 확인하고, 2. 모양을 넣었을 때 최댓값을 확인 및 갱신한다
*/
#include <iostream>
#include <algorithm>
using namespace std;

int N,M, ans;
int map[550][550];
int dy[5][4][4] = {  // [종류][회전][칸수(4칸)]
    {{0,0,0,0}, {0,1,2,3},   {0,0,0,0},{0,0,1,2}},  // ㅡ, ㄴ(뒤집음)
    {{0,0,1,1}, {0,1,2,2},   {0,0,0,1},{0,1,1,1}},  // ㅁ, ㄴ(뒤집음)
    {{0,1,2,2}, {1,1,1,0},   {0,0,1,2},{0,0,0,1}},  // ㄴ, (더미)

    {{0,1,1,2}, {0,0,1,1},   {0,1,1,2},{0,0,1,1}},  // (번개)
    {{0,0,0,1}, {0,1,1,2},   {0,1,1,1},{0,1,1,2}}   // ㅜ

};
int dx[5][4][4] = {
    {{0,1,2,3}, {0,0,0,0},   {0,1,2,3},{0,1,0,0}},  // ㅡ,ㅣ
    {{0,1,1,0}, {1,1,1,0},   {0,1,2,2},{0,0,1,2}},  // ㅁ
    {{0,0,0,1}, {0,1,2,2},   {0,1,1,1},{0,1,2,0}},  // ㄴ

    {{0,0,1,1}, {1,2,0,1},   {1,0,1,0},{0,1,1,2}},  // (번개)
    {{0,1,2,1}, {0,0,1,0},   {1,0,1,2},{1,0,1,1}}   // ㅜ
};

int CheckRange(int, int, int, int);

int main()
{
    int i,j,k,m,n, y,x, sum;
    ios_base::sync_with_stdio(0);  cin.tie(0);  cout.tie(0);

    // 입력부
    cin>>N>>M;
    for(i=0; i<N; i++)
        for(j=0; j<M; j++)
            cin>>map[i][j];

    // 실행부
    y=0;  x=0,  sum=0;
    for(i=0; i<N; i++)  // 맵의 각 위치에서 5종류 테트리미노, 4방향 회전 시킨 것을 모두 넣어 본다 (가능한 모양을 모두 넣어봄)
        for(j=0; j<M; j++)
            for(m=0; m<5; m++)  // m: 종류
                for(k=0; k<4; k++)  // k: 회전
                {
                    // 테트리미노를 넣을 수 없다면
                    if( -1 == CheckRange(i,j,m,k) ) continue;  // 맵 밖으로 벗어나는 경우 넘긴다

                    // 테트리미노를 넣을 수 있다면
                    for(n=0; n<4; n++)  // n: 1칸 인덱스
                    {
                        y = i + dy[m][k][n];
                        x = j + dx[m][k][n];

                        sum += map[y][x];
                    }

                    // 정답 갱신
                    ans = max(ans, sum);

                    // 사용한 변수 초기화
                    sum = 0;
                }

    // 출력부
    cout<<ans;

    return 0;    
}

int CheckRange(int yy,int xx,int num, int dir)
{
    int i, y,x;

    // 해당 모양을 이루는 1칸씩 조사
    for(i=0; i<4; i++)
    {
        y = yy + dy[num][dir][i];
        x = xx + dx[num][dir][i];

        // 맵을 벗어나는 경우
        if(y<0 || x<0 || y>=N || x>=M) return -1;
    }

    // 맵 안에 존재하는 경우
    return 1;
}
