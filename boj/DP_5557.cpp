/* DP_5557, 1학년 */
/* 포인트
 (DP)문제
 1. DP의 "인덱스"([][])로 들어가는 곳의 인자는 "고유한 노드"를 표현 할 수 있도록 착안해서 결정해야한다.
    방문해야하는 2^100개의 노드가 실제로 중복되는 것을 제거하면 "DP[][] 개의 노드만 확인하면 됨"을 의미한다.
 2. N의 최댓값이 100이므로, 이진트리 착안하면 생성되는 노드 갯수가 2^100개(내려갈때 마다 노드 갯수 2배)이고, 이 노드를 전부 다 고려하면 시간초과 난다.
    따라서 DP 사용할 생각을 해야하고 중복 되는 노드의 경우(DFS의 인자 값이 똑같은 경우)를 DP를 이용해서 피할 생각을 해야한다.
 3. "그림"을 그려야한다. 노드 연결상태를 나타내는 그림을 그린다. 맵에서 이동하는 DP가 아니므로 그림 그릴 생각을 못하는데, 그림을 꼭 그려야함...
    그림 그리고 딱 2가지만 체크한다. 1."고유한 노드를 표현하기 위한 값"(이 경우 계산값, 선택한 인덱스), 2."엣지"(이 경우 연산 +,-)  
 4. "자식노드 호출" == "엣지" 라고 생각하자. +,- 엣지가 있으므로.. DFS 2번 호출 하면 된다
 5. DP 내부에서 자식 노드 반환 값을 누적할 때 사용하는 ret 변수도 long long 이어야 한다.. 실수하기 좋다 ㅠ
*/
#include <iostream>
using namespace std;

int N;
long long DP[25][110];  // [계산 값][현재까지 선택한 원소 인덱스] 고유한 노드 만들어지는 경우의 수를 모두 고려해서 인자를 잡아야 한다.
int val[110];

long long DFS(int, int);

int main()
{
    int i,j;
    ios_base::sync_with_stdio(0);  cin.tie(0);  cout.tie(0);

    // 입력부
    cin>>N;
    for(i=0; i<N; i++)
        cin>>val[i];
    
    // DP초기화 (DP 초기값 0과, 정답에 도달하지 못하는경우 DP 값 0을 구분하기 위해서. DP 초기값을 -1로 초기화 한다)
    for(i=0; i<=20; i++)  // 중간 계산 값은 20 까지 밖에 안나온다
        for(j=0; j<=N; j++)  // 우리가 사용할 원소 갯수까지만 N값을 초기화 해줌
            DP[i][j]=-1;

    // 실행부
    cout<<DFS(val[0],1);  // 누적 계산값:(첫번째 원소 값),  현재 선택한 원소 갯수:1  

    return 0;
}

long long DFS(int num, int cnt)  // 깊이는 선택한 갯수(cnt==N) 까지 내려간다
{
    long long ret=0;  // 자식 노드 반환값 누적하는데 사용할 것임. 누적 후에 현재 노드 DP값에 넣어줄 것임

    // 종료 조건 (가지치기)
    if(num<0 || num>20) return 0;   // 계산 값이 범위 내에 없는 경우
    if(cnt==N-1 && num==val[N-1]) return 1;  // 정답인 경우 (원소 N-1개 택해서 계산한 값과, 맨 오른쪽 원소(정답)과 같은지 확인한다)
    if(cnt==N-1 && num!=val[N-1]) return 0;  // 정답이 다른 경우
    if(DP[num][cnt]!=-1) return DP[num][cnt];  // DP값이 존재한다면 출력

    // 자식 노드 호출
    ret += DFS(num + val[cnt], cnt+1);  // 현재 노드 값에 + 연산 적용, 선택한 횟수 증가
    ret += DFS(num - val[cnt], cnt+1);  // 현재 노드 값에 - 연산 적용, 선택한 횟수 증가
    
    // 자신의 DP값 반환
    return DP[num][cnt] = ret;
}

